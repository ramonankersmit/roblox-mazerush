<roblox version="4">
  <Item class="Model" referent="RBX0">
    <Properties>
      <string name="Name">TrapDoor</string>
    </Properties>
    <Item class="Part" referent="RBX1">
      <Properties>
        <string name="Name">Frame</string>
        <bool name="Anchored">true</bool>
        <bool name="CanCollide">true</bool>
        <bool name="CanTouch">true</bool>
        <bool name="CanQuery">true</bool>
        <token name="TopSurface">Smooth</token>
        <token name="BottomSurface">Smooth</token>
        <Vector3 name="Size">8,1,8</Vector3>
        <CoordinateFrame name="CFrame">1,0,0,0,1,0,0,0,1,0,0.5,0</CoordinateFrame>
      </Properties>
    </Item>
    <Item class="Part" referent="RBX2">
      <Properties>
        <string name="Name">Door</string>
        <bool name="Anchored">true</bool>
        <bool name="CanCollide">true</bool>
        <bool name="CanTouch">true</bool>
        <bool name="CanQuery">true</bool>
        <token name="TopSurface">Smooth</token>
        <token name="BottomSurface">Smooth</token>
        <Vector3 name="Size">6,1,6</Vector3>
        <CoordinateFrame name="CFrame">1,0,0,0,1,0,0,0,1,0,0.55,0</CoordinateFrame>
      </Properties>
    </Item>
    <Item class="Script" referent="RBX3">
      <Properties>
        <string name="Name">TrapDoorController</string>
        <bool name="Disabled">true</bool>
        <ProtectedString name="Source"><![CDATA[local Workspace = game:GetService("Workspace")

local model = script.Parent
if not (model and model:IsA("Model")) then
    return
end

local door = model:FindFirstChild("Door")
if not (door and door:IsA("BasePart")) then
    door = model:FindFirstChildWhichIsA("BasePart")
end
if not door then
    warn("[TrapDoor] Geen deur gevonden voor " .. model:GetFullName())
    return
end

if not model:GetAttribute("ObstacleType") then
    model:SetAttribute("ObstacleType", "TrapDoor")
end

door.Anchored = true

local dropTrigger = model:FindFirstChild("DropTrigger")
if not (dropTrigger and dropTrigger:IsA("BasePart")) then
    dropTrigger = Instance.new("Part")
    dropTrigger.Name = "DropTrigger"
    dropTrigger.Parent = model
end
dropTrigger.Anchored = true
dropTrigger.CanCollide = false
dropTrigger.CanTouch = true
dropTrigger.CanQuery = false
dropTrigger.Transparency = 1
dropTrigger.Massless = true

local warningGui = model:FindFirstChild("WarningSign")
if not warningGui then
    local frame = model:FindFirstChild("Frame")
    if frame then
        warningGui = frame:FindFirstChild("WarningSign")
    end
end

local warningLabel
if warningGui and warningGui:IsA("SurfaceGui") then
    warningLabel = warningGui:FindFirstChildWhichIsA("TextLabel")
end

local openDuration = tonumber(model:GetAttribute("OpenDuration")) or 2
if openDuration < 0 then
    openDuration = 0
end

local closedDuration = tonumber(model:GetAttribute("ClosedDuration")) or 4
if closedDuration < 0 then
    closedDuration = 0
end

local warningDuration = tonumber(model:GetAttribute("WarningDuration")) or 0.5
if warningDuration < 0 then
    warningDuration = 0
end

local openTransparency = tonumber(model:GetAttribute("OpenTransparency")) or 0.85
local warningTransparency = tonumber(model:GetAttribute("WarningTransparency"))
if warningTransparency == nil then
    warningTransparency = math.clamp(openTransparency * 0.5, 0, 1)
end

local closedTransparency = tonumber(model:GetAttribute("ClosedTransparency"))
if closedTransparency == nil then
    closedTransparency = door.Transparency
end

local baseCFrame = door.CFrame
local dropTriggerSize = Vector3.new(
    math.max(door.Size.X - 0.25, 1),
    math.max(door.Size.Y + 2.5, 3),
    math.max(door.Size.Z - 0.25, 1)
)
dropTrigger.Size = dropTriggerSize
dropTrigger.CFrame = baseCFrame

local dropCooldowns = setmetatable({}, { __mode = "k" })
local DROP_COOLDOWN = 1.5
local cachedSpawnPart
local teleportTargetPosition

local function updateTeleportTarget()
    local attr = model:GetAttribute("TeleportTargetPosition")
    if typeof(attr) == "Vector3" then
        teleportTargetPosition = attr
    else
        teleportTargetPosition = nil
    end
end

updateTeleportTarget()
if model.GetAttributeChangedSignal then
    model:GetAttributeChangedSignal("TeleportTargetPosition"):Connect(updateTeleportTarget)
end

local function findPlayerSpawn()
    if cachedSpawnPart and cachedSpawnPart.Parent then
        return cachedSpawnPart
    end
    local spawns = Workspace:FindFirstChild("Spawns")
    if not spawns then
        return nil
    end
    local spawnPart = spawns:FindFirstChild("PlayerSpawn")
    if spawnPart and spawnPart:IsA("BasePart") then
        cachedSpawnPart = spawnPart
        return spawnPart
    end
    return nil
end

local function computeTeleportCFrame()
    if teleportTargetPosition then
        return CFrame.new(teleportTargetPosition)
    end

    local spawnPart = findPlayerSpawn()
    if spawnPart then
        local offsetY = (spawnPart.Size.Y or 1) + 4
        return spawnPart.CFrame * CFrame.new(0, offsetY, 0)
    end
    return baseCFrame * CFrame.new(0, -12, 0)
end

local function teleportCharacter(character)
    if not character then
        return
    end
    local now = os.clock()
    local last = dropCooldowns[character]
    if last and (now - last) < DROP_COOLDOWN then
        return
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return
    end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not (root and root:IsA("BasePart")) then
        return
    end

    dropCooldowns[character] = now

    local targetCFrame = computeTeleportCFrame()
    if targetCFrame then
        root.CFrame = targetCFrame
    else
        root.CFrame = baseCFrame * CFrame.new(0, -12, 0)
    end
    root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
end

local function processPart(part)
    if not (part and part:IsA("BasePart")) then
        return
    end
    if part:IsDescendantOf(model) then
        return
    end
    if model:GetAttribute("State") ~= "Open" then
        return
    end
    teleportCharacter(part.Parent)
end

dropTrigger.Touched:Connect(processPart)

local function processOccupants()
    if model:GetAttribute("State") ~= "Open" then
        return
    end
    for _, part in ipairs(dropTrigger:GetTouchingParts()) do
        processPart(part)
    end
end

local hingeOffset = Vector3.new(0, 0, door.Size.Z / 2)

local function setDoorAngle(angle)
    local hingeCFrame = baseCFrame * CFrame.new(hingeOffset)
    local rotated = hingeCFrame * CFrame.Angles(math.rad(angle), 0, 0) * CFrame.new(0, 0, -door.Size.Z / 2)
    door.CFrame = rotated
end

local function setDoorState(state)
    if state == "open" then
        door.CanCollide = false
        door.CanTouch = false
        door.Transparency = openTransparency
        setDoorAngle(-110)
        if warningLabel then
            warningLabel.TextColor3 = Color3.fromRGB(170, 255, 255)
        end
        model:SetAttribute("State", "Open")
        dropTrigger.CFrame = baseCFrame
        task.defer(processOccupants)
    elseif state == "warning" then
        door.CanCollide = true
        door.CanTouch = true
        door.Transparency = warningTransparency
        setDoorAngle(-35)
        if warningLabel then
            warningLabel.TextColor3 = Color3.fromRGB(255, 221, 85)
        end
        model:SetAttribute("State", "Warning")
        dropTrigger.CFrame = baseCFrame
    else
        door.CanCollide = true
        door.CanTouch = true
        door.Transparency = closedTransparency
        setDoorAngle(0)
        if warningLabel then
            warningLabel.TextColor3 = Color3.fromRGB(255, 85, 64)
        end
        model:SetAttribute("State", "Closed")
        dropTrigger.CFrame = baseCFrame
    end
end

setDoorState("closed")

local running = true

script.Destroying:Connect(function()
    running = false
end)

model.AncestryChanged:Connect(function(_, parent)
    if not parent then
        running = false
    end
end)

local function cycle()
    while running and model.Parent do
        setDoorState("closed")
        if closedDuration > 0 then
            task.wait(closedDuration)
        end

        if not running or not model.Parent then
            break
        end

        if warningDuration > 0 then
            setDoorState("warning")
            task.wait(warningDuration)
        end

        if not running or not model.Parent then
            break
        end

        setDoorState("open")
        if openDuration > 0 then
            task.wait(openDuration)
        end

        if not running or not model.Parent then
            break
        end
    end
    setDoorState("closed")
end

task.spawn(cycle)]]></ProtectedString>
      </Properties>
    </Item>
  </Item>
</roblox>
